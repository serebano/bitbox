import nextTick from "./nextTick";
import builtIns from "./builtIns";
import wellKnowSymbols from "./wellKnownSymbols";

export const proxies = new WeakMap();
export const observers = new WeakMap();
export const queuedObservers = new Set();
const enumerate = Symbol("enumerate");
const handlers = { get, ownKeys, set, deleteProperty };

let queued = false;
let currentObserver;

export default {
    observe,
    observable,
    isObservable
};

export function observe(fn, context, ...args) {
    if (typeof fn !== "function") {
        throw new TypeError("First argument must be a function");
    }
    args = args.length ? args : undefined;
    const observer = { fn, context, args, observedKeys: [], exec, unobserve, unqueue };
    runObserver(observer);

    return observer;
}

function exec() {
    runObserver(this);
}

function unobserve() {
    if (this.fn) {
        this.observedKeys.forEach(unobserveKey, this);
        this.fn = (this.context = (this.args = (this.observedKeys = undefined)));
        queuedObservers.delete(this);
    }
}

function unqueue() {
    queuedObservers.delete(this);
}

export function observable(obj) {
    obj = obj || {};
    if (typeof obj !== "object") {
        throw new TypeError("first argument must be an object or undefined");
    }
    return proxies.get(obj) || toObservable(obj);
}

function toObservable(obj) {
    let observable;
    const builtIn = builtIns.get(obj.constructor);
    if (typeof builtIn === "function") {
        observable = builtIn(obj, registerObserver, queueObservers);
    } else if (!builtIn) {
        observable = new Proxy(obj, handlers);
    } else {
        observable = obj;
    }
    proxies.set(obj, observable);
    proxies.set(observable, observable);
    observers.set(obj, new Map());
    return observable;
}

export function isObservable(obj) {
    if (typeof obj !== "object") {
        throw new TypeError("first argument must be an object");
    }
    return proxies.get(obj) === obj;
}

function get(target, key, receiver) {
    if (key === "$raw") return target;
    const result = Reflect.get(target, key, receiver);
    if (typeof key === "symbol" && wellKnowSymbols.has(key)) {
        return result;
    }
    const isObject = typeof result === "object" && result;
    const observable = isObject && proxies.get(result);
    if (currentObserver) {
        registerObserver(target, key);
        if (isObject) {
            return observable || toObservable(result);
        }
    }
    return observable || result;
}

function registerObserver(target, key) {
    if (currentObserver) {
        const observersForTarget = observers.get(target);
        let observersForKey = observersForTarget.get(key);
        if (!observersForKey) {
            observersForKey = new Set();
            observersForTarget.set(key, observersForKey);
        }
        if (!observersForKey.has(currentObserver)) {
            observersForKey.add(currentObserver);
            currentObserver.observedKeys.push(observersForKey);
        }
    }
}

function ownKeys(target) {
    registerObserver(target, enumerate);
    return Reflect.ownKeys(target);
}

function set(target, key, value, receiver) {
    if (key === "length" || value !== Reflect.get(target, key, receiver)) {
        queueObservers(target, key);
        queueObservers(target, enumerate);
    }
    if (typeof value === "object" && value) {
        value = value.$raw || value;
    }
    return Reflect.set(target, key, value, receiver);
}

function deleteProperty(target, key) {
    if (Reflect.has(target, key)) {
        queueObservers(target, key);
        queueObservers(target, enumerate);
    }
    return Reflect.deleteProperty(target, key);
}

function queueObservers(target, key) {
    const observersForKey = observers.get(target).get(key);
    if (observersForKey && observersForKey.constructor === Set) {
        observersForKey.forEach(queueObserver);
    } else if (observersForKey) {
        queueObserver(observersForKey);
    }
}

function queueObserver(observer) {
    if (!queued) {
        nextTick(runObservers);
        queued = true;
    }
    queuedObservers.add(observer);
}

function runObservers() {
    queuedObservers.forEach(runObserver);
    queuedObservers.clear();
    queued = false;
}

function runObserver(observer) {
    try {
        currentObserver = observer;
        observer.fn.apply(observer.context, observer.args);
    } finally {
        currentObserver = undefined;
    }
}

function unobserveKey(observersForKey) {
    observersForKey.delete(this);
}
